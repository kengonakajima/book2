# オンラインゲームの典型的な作り方パターンぜんぶをリスト化

以下、ゲームのだいたいの内容について、
クラサバ/P2Pで典型的な実装パターンとパケットの内容の構成、インフラの構成、
簡単な見積もりを500文字~1000文字ぐらい+図を2個ぐらいで解説、全て列挙する。
いまわかっているゲームジャンルのほとんどについて、
実装仕様のたたき台になるようなもの。


最初h,ジャンルと実装方法のマトリックスで整理しようとしたが、無理だった。。ので、個別のゲームに似てるものを列挙していく方法にしてみる。

## 実装パターンのいくつかの軸

基本パターンは、ゲームロジックと描画をどこで実行するのかについて、4つに分類できる。

- A: クラウドロジック、クラウド描画 (CL-CR): ゲームロジックも描画もクラウドインフラで行い、映像を送信する(クラウドゲーミング、クラウドゲームをつくる技術におけるサーバサイドレンダリングを用いるオンラインマルチプレイ)
- B: クラウドロジック、ローカル描画 (CL-LR): ゲームロジックをクラウドインフラで行い、端末側で描画だけする。(MMOやマイクラのRealm) vol.1本におけるC/S MMO(C/S MO)タイプがこれにあたる。
- C: リモートロジック、ローカル描画 (RL-LR): ゲームロジックは誰か別のユーザーの端末でやり、各端末で描画をする。(多くのスマホゲー)　通信はP2Pまたはリレーを使う。 vol.1本における P2PMOタイプがこれにあたる。
- D: ローカルロジック、ローカル描画 (LL-LR): 通信をしないマルチプレイゲーム。(クラウドゲームをつくる技術における、オフラインマルチプレイ)

ネットコードが必要なのはB,C。ネットコードを実装しない方法については割愛。

UEのサーバーモードやUnityのheadlessモードのように、
Cパターンのサーバー出力を用いる場合はCのホストがクラウドにあるだけなのでCの一部とする。
Cで対応できる人数は帯域や処理負荷の関係から限られるのと、チートしやすいので、
Bは大人数+チート防止のために使われる。

CとBは要件が違うので、CとBの両方についてこうするというのが示されたら良い。

Bはサーバーが、許される範囲でゲームの更新をできるだけ多くクライアントに送りたい。
何をどれだけ送ることができるか?送らないことができるか?どうやって?を考える。
サーバーが電ぷちにならないので、バグらない限りサーバーは正常終了を期待できる。

Cはホスト型とフルメッシュ型がある。ホスト型はシンプルで簡単。考えることはBと同じ。
ホスト型はホストになってる端末が突然電ぷちやネット切断するので、その対処をどうするか。通常は無視。
フルメッシュはレイテンシを減らせる利点や、ホストが落ちた時の移行がしやすいとされてきたが、
ホスト型でも同じことができるので今は必要がない。

端末から送信するのは300から500Kbps ( 40から70KBytes/sec ) 以下におさえたい。
サーバーから送るのも1人あたりはその程度におさえたい。
それだけの量のパケットを処理するCPU負荷自体は端末側は大したこと無い。サーバー側は人数による。

同期方法は、3つに分けれる。

- 完全同期: 遅延してもいいから、ホストから最新状態が来るのを待ってて不完全な状態をプレイヤーに見せない。「脱同期」の状態がない。完全同期でサーバをクラウドの専用サーバにすることでチートを減らすか、無くせる。
- ロールバックつき同期: 決定論的ゲームについて、ホストからのデータが遅延しているときは同期しなくなる(脱同期)。　計算結果が一致しないときは一致してるところまでロールバックする。
- 不完全同期: ゲストとホストで独立にゲームを進めて、必要なデータについては互いに送り合う。そのため通信ができないと同期しなくなる(脱同期)。脱同期したあとは、必要に応じて重要なデータについては戻す。重要ではないデータについては放置する。


同期データの送信方法は、以下のようなパターンに分けられる。

- unicast : 単一のピアに対してのみ送る
- broadcast(bcast) : 全ピアに対して送る
- multicast(mcast) : 列挙した複数のピアに送る
- nearcast : 一定距離以内の全ピアに送る
- scorecast : 一定スコアを超えた全ピアに送る
- pull : クライアントからサーバ(ゲストからホスト)に要求して取得する。　


同期データ(バイト列)をゲームプログラムにおいて作り出すには、
オブジェクト走査をする方法と、状態変更関数を用いる方法がある。
ほとんどのゲームでオブジェクト走査を採用できる。
オブジェクト走査では、
すべてのオブジェクトの更新(Update)が終わったあと、前回の状態と現在の状態を比較して、
変化があったらそれをシリアライズして送信する。つまりオブジェクトの走査をするには、
前回の状態を記憶するだけのメモリ量と、全部を走査するためのCPUコストがかかる。
オブジェクトが極端に多く、ほとんどのオブジェクトが変化しないようなゲームでは、
メモリ量と走査のコストをなくすために、書き込み関数の方法を用いる。
書き込み関数を使うとは、例えば、C++であるオブジェクトobjの位置を変更するとき、 
```obj.position.x += 2;```
と書くのではなく、位置を変更するための関数を定義し、
``` modifyPosition(obj,2,0,0);```
以上のように関数を呼び出し、関数内で同期用のパケットの内容を生成して送信バッファに積む。
オブジェクトが極端に多く、多くのオブジェクトが変化するようなゲームでは、
そのゲームの特性に応じて専用に設計された同期データ生成のアルゴリズムが必要になる。




# 例: ディアブロ的なハクスラ

- プレイヤー数: Cなら4から10　Bなら100程度まで
- 敵の数: Cなら30から200,　Bなら1000程度まで
- 同期対象: すべて。
- 同期方法: ロールバック式を使うにはゲームの状態空間が大きいので、第1案は不完全同期、次が不完全同期。
主に動くもの: 敵。95%は敵の位置や状態の更新。(id32,x32,y32,z32,status32)で20バイト。次がプレイヤーの更新。
- 通信内容/量: 100個の敵の更新(20バイト)を毎秒60回送ると 100x20x60=120KB/s (1Mbps)  これに人数をかける。これを5分の1に減らして1人あたり24KB/sぐらいにしたい。
- 削減手段: 送信間隔を10分の1にする(6フレームに1回)。　素直に実装するとゲスト側で動きがカクカクする(課題)。 Bならnearcastも使える。
- 課題への対策:　単純に同期のEaseを入れる。ゲストにもホストと同じロジックを入れて敵を先行して動かし、位置がずれたら上書きする。
- 決めの問題: 敵への攻撃をホストで判定するかゲストで判定するか。Bはホスト一択。Cはゲストでやるとラグの感じが小さいのでおすすめ。
- UDP: 信頼性あり(RUDP)でもなしでも構わない。位置だけを送るときはなしでOK、状態なども含む場合はありにする。


# 例: ストリートファイター

- プレイヤー数:2
- 同期対象: すべて。プレイヤーキャラ2つと飛び道具、樽とか木、床などの破壊可能な地形が若干数。
- 同期: ロールバックつき完全同期(GGPO)。
ゲームを決定論的に実装し、2台の端末の入力を厳密に同じにして、入力の不一致を検出したら一致しているフレームまで戻す。高速なロールバックを可能にするために、ゲームプレイ空間が十分に小さいことが条件。プレイヤーキャラ2人分と地形など全部で数十バイトから数百以下にシリアライズ、デシリアライズできていれば問題がない。数KB以上と大きくなるとだんだん難しくなる。
チートを防ぐためにクラウドサーバーに第3のプレイヤーとして検算用サーバを起動しておけば、
完全同期を採用しなくても、異常な計算結果になっている端末を結果的に排除することができる。
- 通信量: コントローラーの情報を毎フレーム送る。(タイムスタンプ32、ビット列32)合計8バイトを互いにUDPで送る。8x60=480バイト/s。UDPヘッダ(+40)入れると48x60=2880B/sec。　これで十分に軽いので、通信量を削減する必要はない。 通信帯域に余裕があるので、パケットロスによるロールバックを防ぐために、パケットに前回の入力を冗長に含めることで1個のパケットが消えることの影響を最小化できる。さらに余裕があれば2回分以上を含めることもできる。


# 例: 塗り/陣取り、スプラトゥーン (2D/3D共通)

- プレイヤー数: 4~16
- 同期対象: すべて。プレイヤーの位置とステータス、陣地の状態。陣地の状態は大きくてもよい。
- 同期: 第1案は不完全同期。次が完全同期。 勝敗はホスト役で判定、多少の不一致は無視。
プレイヤーの状態を各端末からホストに毎フレーム送る(20バイト程度)、ホストはそれをbcast、これが90%。塗ったときに変更箇所の分も同様。
ホストからの送信は、8人の場合は(20+UDPヘッダ40)バイト x 60FPS x 8人 =  28800B/s = 230Kbps で十分軽いが、
送信レートを下げて削減するのもよい。
塗りは、各端末で独立に判定してホストに送信、無条件に受け入れて変更されたらbcast.
どうしてもチートを防ぎたい場合はBで完全同期にする。
検算サーバを立てておいて検算サーバの結果と大幅に違う場合は端末での結果を強制的に上書きする案は避ける。　



# 例: PUBG/Fortnite

ほぼMMOだが、1プロセスで1ゲームをホストする。 ゲーム間の連携はない。
- プレイヤー数: 100~200
- 建造物数: 5000~50000
- 同期対象: 近くのキャラや建造物(95%)+少量の全体ステータス(タイマーとかフラグ、ログ)
- 同期: Bで不完全同期。サーバーの処理を正とするが、
サーバーと各端末は同じゲームロジック(物理シミュレーション処理)を動かす。
プレイヤーの操作はすべてサーバーに送り、サーバで全てを処理する。
一定距離範囲内のキャラ を毎秒5~20回サーバからnearcastまたは変化量によるscorecast.
Mobを含むキャラの出現と削除は常にbcast.
建造物はマップを20m程度のチャンクに分けて、新しいチャンクに入ったことをクライアントで検出したらpullする。
チャンク内の変化分(設置や破壊)はサーバからnearcast.
nearcastの送信量は距離で調整可能にし、開発を進めながら最適な設定を見つける。
一時的に高密度になる場合があるので、動的にnearcastの範囲を決定する。
建造物の変化速度は遅いので、ほぼすべてキャラの動きになる。
- 通信量: 平均の密度を10人、同期内容を(20+40)byte とすると、毎秒20回とすれば
サーバからの送信は、20回/sec x (20+40)byte x 10人分 x 100 CCU = 1200KBytes/sec。
- 処理負荷: 全プレイヤー、MOB、投擲物、壊れたものなどの数が、コリジョンも含めると多くなる。
それらの全部について物理計算をサーバーでやるのは重すぎるかもしれない。その場合は、
衝突判定だけクライアントでやるようにして、チートの可能性を大きくしつつも、負荷を逃がすことができる(PUBG)。
処理の量によっては、C++サーバーを用いるか、UEのServerやUnityのヘッドレスなどを使って実装することも可能。
Ruby,PHP,Pythonでは無理。


# 例: Quake的な地形変更が少ないFPS

- プレイヤー数: 8~32
- 同期対象: プレイヤーの位置と全アクション、ステータス(95%)、ゲーム全体の状態フラグ
- 同期: Cで不完全同期、ホストの結果を正としてホストから結果をすべてbcast
毎tickゲストからホストにキャラ操作を送り、毎tickホストからゲストにUDPでbcast.
位置とアクションは信頼性なしでOK。
tickは毎秒20回から60回、LANであればそれ以上でも可。
- 通信量: ホストからの送信はbroadcastで、
16人分 x 60回/sec x (20+40)Byte x 16CCU = 921600bytes/sec で結構多い。あまり人数は増やせない。
ゲストで脱同期してるときは強制的に上書き。モバイルの場合はこの通信量だと多すぎるため、
送信レートを下げたりnearcastを併用する。送信頻度を毎秒10回として6分の1、
nearcastを使って送信量を3分の1程度に押さえれば3~400Kbpsになる。
- チート: チートを厳密に防ぎたいときはBでゲストの結果を常に上書き。そうでないときはC。
- プレイ感の改善: 最初はキャラの動作や地形の破壊や範囲攻撃などすべてについて、すべてホストで判定して、ゲストの結果を上書きするように実装する。
開発を進めながら、プレイ感覚が悪いところについて、自分のキャラの位置、自分の攻撃のヒット判定、自分への攻撃のヒット判定について、
ゲストでやるか、ホストでやるかをひとつづつ調整していく。

# マリカー
- プレイヤー数: 4~16
- 同期対象: FPSと同様。プレイヤーの位置、全アクション、ステータス、ゲーム全体の状態フラグ
- 同期: Cで不完全同期
- チート: FPSと同様
- プレイ感の改善: コース上にあるもの(アイテム、他車、武器など)との衝突はすべて各端末のローカルで行い、見た目上正確に当たっているようにする。長い距離を飛んでいく飛び道具の武器については、撃った瞬間に移動方向が決まるものについては撃った事実だけを送信して各端末でローカルに計算、ホーミングするなどカオスな動きをするものは、各端末でローカルに計算して、脱同期おかまいなしにするか、撃ったプレイヤーが位置を計算してほかの端末にbcastする。最初にすべて決めず、実際にプレイしながら調整。


# パターン一覧

- 地形変更ありオープンワールド: マイクラ
- ioゲーム(agar.io, snowball.io, ボンバーマン的なPvP)
- super mario makerの COOPモード
- 2d sandbox: Terraria
- 2d platformer jump: metroidvania
- sim city / factorio
- MMOじゃないモンハン
- PUBG
- MOBA: LoL
- FPS, 地形変わらないか、破壊だけのquake的なやつ
- 塗り/陣取り  splatoon
- 少人数PvP スマブラ
- ボンバーマン
- ぷよぷよの対戦
- tetris 99
- FIFA的なスポーツゲーム
- 無双
- ディアブロ的なハクスラ
- クラロワ
- MMORPG
- マリカー
- ストリートファイター
- マリオテニス
- turn based : 囲碁将棋麻雀
- シャドバとかハースストーンみたいなカードゲーム
- RTS: Age of empires
- マルチプレイの音ゲーってあるんかな
- VRChat的な
