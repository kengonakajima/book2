# オンラインゲームの典型的な作り方パターンぜんぶをリスト化

以下、ゲームのだいたいの内容について、
クラサバ/P2Pで典型的な実装パターンとパケットの内容の構成、インフラの構成、
簡単な見積もりを500文字~1000文字ぐらい+図を2個ぐらいで解説、全て列挙する。
いまわかっているゲームジャンルのほとんどについて、
実装仕様のたたき台になるようなもの。


最初h,ジャンルと実装方法のマトリックスで整理しようとしたが、無理だった。。ので、個別のゲームに似てるものを列挙していく方法にしてみる。

## 実装パターンのいくつかの軸

基本パターンは、ゲームロジックと描画をどこで実行するのかについて、4つに分類できる。

- A: クラウドロジック、クラウド描画 (CL-CR): ゲームロジックも描画もクラウドインフラで行い、映像を送信する(クラウドゲーミング、クラウドゲームをつくる技術におけるサーバサイドレンダリングを用いるオンラインマルチプレイ)
- B: クラウドロジック、ローカル描画 (CL-LR): ゲームロジックをクラウドインフラで行い、端末側で描画だけする。(MMOやマイクラのRealm) vol.1本におけるC/S MMO(C/S MO)タイプがこれにあたる。
- C: リモートロジック、ローカル描画 (RL-LR): ゲームロジックは誰か別のユーザーの端末でやり、各端末で描画をする。(多くのスマホゲー)　通信はP2Pまたはリレーを使う。チートを根治できない。 vol.1本における P2PMOタイプがこれにあたる。ホスト役の「電源ぷち」「WiFiぷち」による強制切断が防げない。
- D: ローカルロジック、ローカル描画 (LL-LR): 通信をしないマルチプレイゲーム。(クラウドゲームをつくる技術における、オフラインマルチプレイ)

ネットコードが必要なのはB,C。ネットコードを実装しない方法については割愛。

UEのサーバーモードやUnityのheadlessモードのように、
Cパターンのサーバー出力を用いる場合はCのホストがクラウドにあるだけなのでCの一部とする。
Cで対応できる人数は帯域や処理負荷の関係から限られるのと、チートしやすいので、
Bは大人数+チート防止のために使われる。

CとBは要件が違うので、CとBの両方についてこうするというのが示されたら良い。

Bはサーバーが、許される範囲でゲームの更新をできるだけ多くクライアントに送りたい。
何をどれだけ送ることができるか?送らないことができるか?どうやって?を考える。
サーバーが電ぷちにならないので、バグらない限りサーバーは正常終了を期待できる。

Cはホスト型とフルメッシュ型がある。ホスト型はシンプルで簡単。考えることはBと同じ。
ホスト型はホストになってる端末が突然電ぷちやネット切断するので、その対処をどうするか。通常は無視。
フルメッシュはレイテンシを減らせる利点や、ホストが落ちた時の移行がしやすいとされてきたが、
ホスト型でも同じことができるので今は必要がない。

端末から送信するのは300から500Kbps ( 40から70KBytes/sec ) 以下におさえたい。
サーバーから送るのも1人あたりはその程度におさえたい。
それだけの量のパケットを処理するCPU負荷自体は端末側は大したこと無い。サーバー側は人数による。


同期方法は、3つに分けれる。

- 完全同期: (vol1での同期式)遅延してもいいから、ホストから最新状態が来るのを待ってて不完全な状態をプレイヤーに見せない。「脱同期」の状態がない。ただしネットワーク遅延の分だけいつも反応が遅れる。ロックステップ(lockstep,足を固定した状態で行進する)とも言う。完全同期でサーバをクラウドの専用サーバにすることでチートを減らすか、無くせる。
- ロールバックつき同期(vol1での同期式に工夫を加えたもの): 決定論的ゲームについて、ホストからのデータが遅延しているときは同期しなくなる(脱同期)。　計算結果が一致しないときは一致してるところまでロールバックする。
- 不完全同期: (vo1での非同期式)ゲストとホストで独立にゲームを進めて(client side)、必要なデータについては互いに送り合う。そのため通信ができないと同期しなくなる(脱同期)。脱同期したあとは、必要に応じて重要なデータについては戻す(server authoritative)。重要ではないデータについては放置する。何を、どのような条件でserver authoritativeとするかは、ゲーム内容に応じて考える必要がある。


同期データの送信方法は、以下のようなパターンに分けられる。

- unicast : 単一のピアに対してのみ送る
- broadcast(bcast) : 全ピアに対して送る
- multicast(mcast) : 列挙した複数のピアに送る
- nearcast : 一定距離以内の全ピアに送る
- scorecast : 一定スコアを超えた全ピアに送る
- pull : クライアントからサーバ(ゲストからホスト)に要求して取得する。　


同期データ(バイト列)をゲームプログラムにおいて作り出すには、
オブジェクト走査をする方法と、状態変更関数を用いる方法がある。
ほとんどのゲームでオブジェクト走査を採用できる。
オブジェクト走査では、
すべてのオブジェクトの更新(Update)が終わったあと、前回の状態と現在の状態を比較して、
変化があったらそれをシリアライズして送信する。つまりオブジェクトの走査をするには、
前回の状態を記憶するだけのメモリ量と、全部を走査するためのCPUコストがかかる。
オブジェクトが極端に多く、ほとんどのオブジェクトが変化しないようなゲームでは、
メモリ量と走査のコストをなくすために、書き込み関数の方法を用いる。
書き込み関数を使うとは、例えば、C++であるオブジェクトobjの位置を変更するとき、 
```obj.position.x += 2;```
と書くのではなく、位置を変更するための関数を定義し、
``` modifyPosition(obj,2,0,0);```
以上のように関数を呼び出し、関数内で同期用のパケットの内容を生成して送信バッファに積む。
オブジェクトが極端に多く、多くのオブジェクトが変化するようなゲームでは、
そのゲームの特性に応じて専用に設計された同期データ生成のアルゴリズムが必要になる。


プログラミング言語について

ビデオゲームでよく使われる言語は、だいたい以下の5種類に分けることができる。
プログラミング言語は、純粋な計算だけをするときの処理速度(CPUバウンドの処理)と、
ソケットやGPUなどのハードウェアを使う入出力を多くする場合の処理速度(I/Oバウンド)は別に考える必要がある。
GoやC#はCPUバウンドの処理はC/C++に近い性能を実現できるが、I/Oが多いときは大幅に遅くなる。
これは安全性や移植性を実現するためにI/Oの抽象化レイヤーが厚くなっていることが原因。
オンラインゲームでは、サーバーにおいてはソケットのI/Oがとても多くなるので、I/O性能は重要になる。
クライアントでは当然ながら、描画処理のためにI/Oを大量に行う。

どの言語でもスレッドを使った高速化は可能だが、スレッド間の通信の仕方はそれぞれ異なり、
スレッド間の通信はやはりI/Oバウンドの処理と同じ負荷がかかる。

以下、5つのグループについて 最高速グループのI/O性能と計算性能を100としてだいたいの目安。

最高速: C,C++,Rust   I/O=100 CPU=100
高速: Java,C#,Go,LuaJIT,JavaScript(V8:型付き配列を駆使する場合やwasm) I/O=10 CPU=20~100
中速: JavaScript,TypeScript(V8:素直に書いた場合),Lua I/O=10 CPU=10
低速: Ruby,PHP I/O=5 CPU=2~5
最低速: Python I/O=2 CPU=2

どの言語でも、他の言語のモジュールを読み込んで使うことができる。
I/Oバウンドの処理をC++で書き、そこからCPUバウンドの処理を呼び出して両方の欠点を補うことができる。
UnityではC#からネイティブプラグインを呼び出したり、その逆もできる。Node.jsのモジュールの多くはC++で書かれている。など。

ヘッドレスモードについて

UnityやUE、それ以外のゲームエンジンについても、ゲームロジックを実行するが描画を行わない実行モードが用意されている。
これはヘッドレスと呼ばれている。
GPUを持たないサーバーマシンでゲームプログラム本体を動かしてサーバーとして使うことにより、
サーバー専用のプログラムを別個に実装する手間を省略することができる。

Cパターンの問題はホスト役端末の電源やWiFiが突然来れる、強制終了が問題になるため、
人数をある程度以上増やすことができない。また、RPGやオープンワールドのように数時間以上といった
長時間のプレイセッションに対応することができない。Bではそれに対応できるが、Bを実装するために、
上述したヘッドレスモードが多用される。



# 例: ディアブロ的なハクスラ

- プレイヤー数: Cなら4から10　Bなら100程度まで
- 敵の数: Cなら30から200,　Bなら1000程度まで
- 同期対象: すべて。
- 同期方法: ロールバック式を使うにはゲームの状態空間が大きいので、第1案は不完全同期。
主に動くもの: 敵。95%は敵の位置や状態の更新。(id32,x32,y32,z32,status32)で20バイト。次がプレイヤーの更新。
- 通信内容/量: 100個の敵の更新(20バイト)を毎秒60回送ると 100x20x60=120KB/s (1Mbps)  これに人数をかける。これを5分の1に減らして1人あたり24KB/sぐらいにしたい。
- 削減手段: 送信間隔を10分の1にする(6フレームに1回)。　素直に実装するとゲスト側で動きがカクカクする(課題)。 Bならnearcastも使える。
- 課題への対策:　単純に同期のEaseを入れる。ゲストにもホストと同じロジックを入れて敵を先行して動かし、位置がずれたら上書きする。
- 決めの問題: 敵への攻撃をホストで判定するかゲストで判定するか。ゲストでやることでラグの感じを小さくできる。敵をspawnはホストで決める。削除はゲストでやって同期でOK
- UDP: 信頼性あり(RUDP)でもなしでも構わない。位置だけを送るときはなしでOK、状態なども含む場合はありにする。
- 実装手順: シングルプレイ版を作る。プレイ開始時にホストに接続する。PCの同期を実装、ゲストでの敵spawnをoffにしてホストでspawnしたものをゲストに出現できるようにする。ゲストでも敵を動かす。ゲストで敵への攻撃を当てる。敵倒しを実装。飛び道具を実装。敵への攻撃ができたらそれ以外は流れで実装できるだろう。

# 例: ストリートファイター

- プレイヤー数:2
- 同期対象: すべて。プレイヤーキャラ2つと飛び道具、樽とか木、床などの破壊可能な地形が若干数。
- 同期: Cでロールバックつき完全同期(GGPO)。
ゲームを決定論的に実装し、2台の端末の入力を厳密に同じにして、入力の不一致を検出したら一致しているフレームまで戻す。高速なロールバックを可能にするために、ゲームプレイ空間が十分に小さいことが条件。プレイヤーキャラ2人分と地形など全部で数十バイトから数百以下にシリアライズ、デシリアライズできていれば問題がない。数KB以上と大きくなるとだんだん難しくなる。
ゲームロジックのCPU負荷が小さい場合、ロールバック後に1フレームに複数回の更新をすることで、時間の巻き戻りを無くすことができる。その場合、キャラクタがワープしたようにみえる。
チートを防ぐためにクラウドサーバーに第3のプレイヤーとして検算用サーバを起動しておけば、
完全同期を採用しなくても、異常な計算結果になっている端末を結果的に排除することができる。
- 通信量: コントローラーの情報を毎フレーム送る。(タイムスタンプ32、ビット列32)合計8バイトを互いにUDPで送る。8x60=480バイト/s。UDPヘッダ(+40)入れると48x60=2880B/sec。　これで十分に軽いので、通信量を削減する必要はない。 通信帯域に余裕があるので、パケットロスによるロールバックを防ぐために、パケットに前回の入力を冗長に含めることで1個のパケットが消えることの影響を最小化できる。さらに余裕があれば2回分以上を含めることもできる。
- 実装手順: コントローラー2個をつないでローカル対戦できるようにする。最初はフレームレート固定で実装すると簡単。そのあと、GGPOを使う場合は、ローカルからの入力をGGPOにまず入力してその出力でゲームをプレイできる状態にする。最後に、開始時にホストに接続して、コントローラーのデータをリモート送信する部分を作成し、すでにできているGGPOへの入力に置換する。

# 例: ぷよぷよの対戦(2人)
ぷよぷよの対戦では、ぷよを消したら、相手側の上からおじゃまぷよが落とされる。
おじゃまぷよの投下タイミングが1フレームずれるだけで致命的に異なるプレイ結果になるため、
厳密なロールバックを用いる必要がある。つまりストリートファイターと同じように、
ゲームロジックを決定論的に実装し、ストリートファイターと同じくロールバック付き完全同期を実装する必要がある。ゲーム全体の状態更新も対戦格闘より重いため、人数も増やすことが難しい。

# 例: テトリス99
テトリス99では、ぷよぷよのおじゃまぷよが上から落ちるのと異なり、ブロックを消したらほかの対戦相手のゲームフィールドの下側からブロックを押し上げるペナルティが発生する。
ゲームフィールドには新しいブロックが上から落ちてくるため、
そのため、通信による遅延でペナルティブロックの出現が数フレーム遅れがあったとしても、
致命的に異なる結果にならない。
100人対戦のプレイ動画で、ロールバックしてる感じが見られるものはないことからもわかる。
- プレイヤー数: 100
- 同期対象: ゲームフィールドの状態すべて
- 同期: Cで不完全同期(完全に同期する必要がない)。リレーサーバー経由での通信。
- 通信量: ひとつのゲームセッションに100人が参加する。ブロックを置いた時、消した時に、どの位置が変わったかを通知する。座標の値が小さいので、8バイト(UDPヘッダ+40)あれば表現できる。この変更は1秒に2回以下しか起きない。これを各端末からリレーサーバーに送る。
ゲーム全体では、100人 x 2回/sec x 8byte = 1600バイト/sec の変化量が発生する。
UDPのヘッダを入れると、 x (8+40)byteになるため、一気に6倍(9600バイト/sec)のデータ量になる。
リレーサーバーは、UDPで受信した同期データをそのまま100人に送信すると、単純に 9600B/sec x 100 = 960KB/sec となる。これでも問題なく実装できるが、変更をある程度の時間(0.1秒間ためておいて、溜まった分を1個の大きなパケットにつめて送る)などの工夫をすることによって、UDPのヘッダを送信する量を大幅に減らすことができる。100人が1秒に発生させる変更イベントは100人 x 2回/sec なので200回、したがって0.1秒間に20個のイベントが発生する。 まとめない場合は 20 x (8+40) = 960バイトの送信が必要なところ、 1 x (8*20+40) = 200バイトとなり、4分の1以下になっている。




# 例: 塗り/陣取り、スプラトゥーン (2D/3D共通)

- プレイヤー数: 4~16
- 同期対象: すべて。プレイヤーの位置とステータス、陣地の状態。陣地の状態は大きくてもよい。
- 同期: 第1案は不完全同期。次が完全同期。 勝敗はホスト役で判定、多少の不一致は無視。
プレイヤーの状態を各端末からホストに毎フレーム送る(20バイト程度)、ホストはそれをbcast、これが90%。塗ったときに変更箇所の分も同様。
ホストからの送信は、8人の場合は(20+UDPヘッダ40)バイト x 60FPS x 8人 =  28800B/s = 230Kbps で十分軽いが、
送信レートを下げて削減するのもよい。
塗りは、各端末で独立に判定してホストに送信、無条件に受け入れて変更されたらbcast.
どうしてもチートを防ぎたい場合はBで完全同期にする。
検算サーバを立てておいて検算サーバの結果と大幅に違う場合は端末での結果を強制的に上書きする案は避ける。　



# 例: PUBG/Fortnite

ほぼMMOだが、1プロセスで1ゲームをホストする。 ゲーム間の連携はない。
- プレイヤー数: 100~200
- 建造物数: 5000~50000
- 同期対象: 近くのキャラや建造物(95%)+少量の全体ステータス(タイマーとかフラグ、ログ)
- 同期: Bで不完全同期。サーバーの処理を正とするが、
サーバーと各端末は同じゲームロジック(物理シミュレーション処理)を動かす。
プレイヤーの操作はすべてサーバーに送り、サーバで全てを処理する。
一定距離範囲内のキャラ を毎秒5~20回サーバからnearcastまたは変化量によるscorecast.
Mobを含むキャラの出現と削除は常にbcast.
建造物はマップを20m程度のチャンクに分けて、新しいチャンクに入ったことをクライアントで検出したらpullする。
チャンク内の変化分(設置や破壊)はサーバからnearcast.
nearcastの送信量は距離で調整可能にし、開発を進めながら最適な設定を見つける。
一時的に高密度になる場合があるので、動的にnearcastの範囲を決定する。
建造物の変化速度は遅いので、ほぼすべてキャラの動きになる。
- 通信量: 平均の密度を10人、同期内容を(20+40)byte とすると、毎秒20回とすれば
サーバからの送信は、20回/sec x (20+40)byte x 10人分 x 100 CCU = 1200KBytes/sec。
- 処理負荷: 全プレイヤー、MOB、投擲物、壊れたものなどの数が、コリジョンも含めると多くなる。
それらの全部について物理計算をサーバーでやるのは重すぎるかもしれない。その場合は、
衝突判定だけクライアントでやるようにして、チートの可能性を大きくしつつも、負荷を逃がすことができる(PUBG)。
処理の量によっては、C++サーバーを用いるか、UEのServerやUnityのヘッドレスなどを使って実装することも可能。
Ruby,PHP,Pythonでは無理。


# 例: Quake的な地形変更が少ないFPS

- プレイヤー数: 8~32
- 同期対象: プレイヤーの位置と全アクション、ステータス(95%)、ゲーム全体の状態フラグ
- 同期: Cで不完全同期、ホストの結果を正としてホストから結果をすべてbcast
毎tickゲストからホストにキャラ操作を送り、毎tickホストからゲストにUDPでbcast.
位置とアクションは信頼性なしでOK。
tickは毎秒20回から60回、LANであればそれ以上でも可。
- 通信量: ホストからの送信はbroadcastで、
16人分 x 60回/sec x (20+40)Byte x 16CCU = 921600bytes/sec で結構多い。あまり人数は増やせない。
ゲストで脱同期してるときは強制的に上書き。モバイルの場合はこの通信量だと多すぎるため、
送信レートを下げたりnearcastを併用する。送信頻度を毎秒10回として6分の1、
nearcastを使って送信量を3分の1程度に押さえれば3~400Kbpsになる。
- チート: チートを厳密に防ぎたいときはBでゲストの結果を常に上書き。そうでないときはC。
- プレイ感の改善: 最初はキャラの動作や地形の破壊や範囲攻撃などすべてについて、すべてホストで判定して、ゲストの結果を上書きするように実装する。
開発を進めながら、プレイ感覚が悪いところについて、自分のキャラの位置、自分の攻撃のヒット判定、自分への攻撃のヒット判定について、
ゲストでやるか、ホストでやるかをひとつづつ調整していく。

# マリカー
- プレイヤー数: 4~16
- 同期対象: FPSと同様。プレイヤーの位置、全アクション、ステータス、ゲーム全体の状態フラグ
- 同期: Cで不完全同期
- チート: FPSと同様
- プレイ感の改善: コース上にあるもの(アイテム、他車、武器など)との衝突はすべて各端末のローカルで行い、見た目上正確に当たっているようにする。長い距離を飛んでいく飛び道具の武器については、撃った瞬間に移動方向が決まるものについては撃った事実だけを送信して各端末でローカルに計算、ホーミングするなどカオスな動きをするものは、各端末でローカルに計算して、脱同期おかまいなしにするか、撃ったプレイヤーが位置を計算してほかの端末にbcastする。最初にすべて決めず、実際にプレイしながら調整。

# クラロワ

- プレイヤー数: 2~4
- 同期対象: すべて
- 同期: オブジェクトの数が少なくロールバックが可能で1タイならCでロールバック完全同期。そうでないならCで不完全同期。チートを防ぎたい度合いによってはBも使える
- 通信量: コントローラー操作ではなくタップまたはクリックの操作だけを通信する。
完全同期では通信頻度は毎フレーム送る必要がなく操作時だけなので、1秒に2~5回以下程度となる。それを2~4人の相手に送るだけなので通信の負荷はごく小さいものになる。 操作の内容も、基本は何のユニットをどこに置いたか、なので20バイトで足りる。 2人で毎秒5回の場合、 2人 x 5回/sec x 20Byte = 200Byte/sec . UDPのヘッダを入れたら(20+40)で600byte. 
不完全同期の場合は、ゲームに参加しているどれかの(どちらか)の端末をホストとし、それ以外をゲストとする。ゲストの操作をホストに送り、ホストですべて動かし、結果をゲストに送る。動くものが全部で最大50ほどで、1体あたり20バイト必要なら、それを毎秒10回送るならば、 50個 x 20バイト = 1000バイト、UDPのヘッダ40をつけて1040バイトを1秒に10回なので 10400バイトで、最大がだいたい80Kbpsとなる。実際にプレイしながら送信レートを下げる方法を工夫する。たとえば移動が遅いキャラは頻度を下げても問題がない。
- プレイ感: ゲームの進行が速くないため、ゲストを純粋なビューワとして実装するので基本的には問題がない。
数フレームの遅延が許されず、どうしても即座のリアクションがほしい場合(たとえばメテオを落とす操作など)は、その操作についてのみ脱同期させてすぐにゲスト側で発動させ、ホストからの上書き(クールダウンタイマーが終わっていないなど)があったらキャンセルさせる。そのばあい、メテオを撃った瞬間メテオが表示されるが、そのすぐあと消える演出になる。　これを防ぐには技のクールダウンタイマー自体をホストからの通信で更新する。


# MMORPG
オンラインゲームを支える技術　での説明から変わっていることがほぼない。
マネージドサービスを使うと楽ができるかもぐらい。些細な違いでしかない。


# マイクラタイプのオープンワールド(地形変更あり)
- プレイヤー数: 1~300 (20以上なら高速以上の言語が必要.)
- 同期対象: すべて
- 同期: 不完全同期。ホスト役の強制終了による問題が大きいのでBが必要。ただしCのロジックをヘッドレスモードにして、そのままクラウドサーバーで動作させることができる。送信の大部分はボクセルの地形のローディングと変化分、モブやアイテムの移動。音やエフェクト、気候、チャットなどは誤差の範囲となる。　ヘッドレス式も専用式もどちらでもOK. DBを駆使したりする場合は専用式が向いている。(MMORPGに準じる)
- 実装手順(ヘッドレス式の場合): 1人で遊べるバージョンを作成したあと、ネットワークを実装する前に、2人以上のプレイヤーが存在できるようにし、自動で動かす。　そのあとネットワーク接続(TCP/UDP)を受け入れるようにし、接続ができたら固定の位置にPCを生成し、周囲の地形データをロードするRPCを実装する。クライアント側のゲームでPCを脱同期して動かし、位置を毎秒10回ぐらいサーバに送信し、ホスト(サーバ)で速すぎないか判定してOKなら受け入れる。ホストで動いたモブの位置をゲストに送る(毎秒10回)。モブへの攻撃はゲストとホストの両方で判定して常にホストの結果を採用する(上書き)。


# MOBA(LOL)


# パターン一覧

- 地形変更ありオープンワールド: マイクラ
- ioゲーム(agar.io, snowball.io, ボンバーマン的なPvP)
- super mario makerの COOPモード
- 2d sandbox: Terraria
- 2d platformer jump: metroidvania
- sim city / factorio
- MMOじゃないモンハン
- PUBG
- MOBA: LoL
- FPS, 地形変わらないか、破壊だけのquake的なやつ
- 塗り/陣取り  splatoon
- 少人数PvP スマブラ
- ボンバーマン
- ぷよぷよの対戦
- tetris 99
- 無双
- ディアブロ的なハクスラ
- クラロワ
- MMORPG
- マリカー
- ストリートファイター
- マリオテニス
- turn based : 囲碁将棋麻雀
- シャドバとかハースストーンみたいなカードゲーム
- RTS: Age of empires
- マルチプレイの音ゲーってあるんかな
- VRChat的な

# 開発における典型的な手順

- ゲームっぽい作り方
通信コードなしで、1人で遊べるものをつくる。オートプレイやセカンドコントローラーを追加して2人以上が関わるで遊べる状態にする。
その状態でゲームの通信して同期する部分を追加する。専用サーバーを(も)提供する場合は、ヘッドレスモードで出力したプログラムを使う。
チート可の場合、基本はリレーサーバーを使って同期を実装する。
チート可で4人以下なら物理構成をP2Pも追加できる。
チート不可の場合は人数によらず、専用に描画処理を削除したゲームプログラムをクラウドで動作させる(ヘッドレスサーバ)。
2020年以降は、数百人程度の接続数であればこれで対応できる。
オンラインゲームを支える技術1で紹介していたP2P MOはこの方法にあたる。

- Webっぽい作り方
ゲームロジックのすべてがクラウドサーバに実装されており、ゲームのクライアントは単なるビューワーとして動作する。
サーバーとクライアントのプログラムはまったく別の設計になっていて、実装する言語が異なることも多い。
オンラインゲームを支える技術1で紹介していたC/S MMOはこの方法にあたる。
ioゲームの多くはゲームのクライアントがブラウザで動作するため、Webっぽい作り方と親和性がよい。

どのゲームでも、Webっぽい作り方と、ゲームっぽい作り方の両方ができる。
汎用ゲームエンジンを用いてゲームプログラムを出力し、エンドユーザーの端末にソフトウェアをインストールさせる場合は、
ゲームっぽい作り方が適している。ブラウザに向けたゲームの場合は巨大なプログラムを配布できないため、
クライアントが小さく、ビューワとして動作するだけのWebっぽい作り方が向いている。


# ゲームロジックのあり方

## ゲームっぽい作り方の場合
ゲームっぽい作り方では、まずGPUに送信するジオメトリデータに直結しているオブジェクト(UnityならGameObject)を追加し、その位置や状態を変更する部分をスクリプトで定義してゲームを作る。

このとき、スクリプトには、キーボード、マウス、タッチデバイス、マイクなど、
端末に搭載されているデバイスからのセンシングデータが入力される。
スクリプトはそのデータを処理してオブジェクトの内容を変更する。

ゲームプレイ空間の情報については、論理データとジオメトリデータを分離する設計と、分離しない設計とがある。

マルチプレイを実装するときに、分離する設計では、論理データの変化を同期する。
分離しない設計では、ジオメトリデータそのものを同期する。

たとえばオセロゲームを作る場合、8x8マスの論理的な状態を、白、黒、なしの3つの状態とし、
8x8=64要素の配列に入れておいて、描画をするときにはその配列の状態をジオメトリに反映させる。
これが、論理データとジオメトリの分離である。分離するモデルの場合は、ネットワークで通信するのは、
ジオメトリの位置ではなく、盤の最新の状態である。

いっぽうでシューティングゲームを作るときは、論理データをジオメトリから分離せずに作ることも多い。
たとえばビームを撃つならば、ジオメトリデータ(GameObject)そのものをインスタンス化し、
毎フレーム呼ばれるUpdate関数の中で位置を更新していく。分離しないモデルの場合は、
ネットワークでジオメトリの座標そのものを送信する。

## Webっぽい作り方の場合

Webっぽい作り方では、まずゲームはサーバで動作させる。サーバにはGPUがないため、
GPUに送信するジオメトリデータそのものが必要ない。

典型的にはNodeなどで実装したサーバーのメモリ上にゲームの論理データがあり、
その論理データの更新分をクライアントにWebSocketで送り、それをクライアントでジオメトリに変換してWebGL描画する。

オセロゲームの例でいうと、ゲームっぽい作り方で説明した、論理データとジオメトリを分離した作り方をするのが基本だと言える。

Webっぽい作り方でシューティングゲームを実装する場合は、サーバー側でも敵キャラクタなどの座標を毎秒数十回動かす必要がある。
その結果をリアルタイムにクライアント(ブラウザ)に送信することで、シューティングゲームのマルチプレイ実装は可能である。
これはクラウドゲームをつくる技術における、抽象度の高いデータを送る方法に近い。

Webぽい作り方は、クライアントでゲームロジックを持たないので、サーバからの結果を待たずにジオメトリを動かすことができない。
したがって、操作してから画面に反映するまでを早くしたいゲームには不向きである。通常サーバーとの通信は30~60ms程度遅れるので、
この数フレームの遅れがプレイ感覚を損ねるようなゲームには使いづらい。

この方法は、サーバーロジックのCPU負荷が高いのと、通信量が多いという問題もある。
クライアントのインストールが不要、すぐプレイを開始できる、
ゲームのリバースエンジニアリングやデータのリッピングを最小限にできるというメリットと、
遅延やCPU/帯域のコストのバランスを考える必要がある。

なお、ブラウザ向けであっても、チートが可能であってもいいゲームについては、
ゲームっぽい作り方をしてリレーサーバーを使って同期をする方法は十分に可能である。多くのioゲームはゲームっぽい作り方で実装されている。

オンラインゲームを支える技術1で説明したとおり、
世界が巨大で、その世界のごく一部だけをみてるようなゲームはWebっぽいのが向いている。







