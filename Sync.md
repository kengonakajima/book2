# 同期の方法を整理

オンラインゲームにおける同期まわりの用語定義と、同期方法の整理。

ゲームの状態の全体を「ゲームプレイ空間」と呼ぶ。
同期とは、あるプロセスAにおけるゲームプレイ空間の状態(ビット列)と、
リモートプロセスBにおけるゲームプレイ空間の状態(ビット列)を、通信を用いて一致させること。

プレイヤーが、リモートプレイヤーとおなじゲームプレイ空間に
自分も参加してると感じるなら、それを「同期の感覚」と呼ぶ。
ビット列が厳密に同期していなくても、同期の感覚を得ることはできる。




ゲームのシミュレーションなどの処理をしてゲームプレイ空間を変更することを、ゲームを進めると言う。
ゲームを進めるためのコードをゲームロジックと呼ぶ。
ゲームロジックはプレイヤーの入力を受け取ってゲームを進め、結果を画面に描画する。

## ゲームの同期における用語
まずサーバとクライアントという用語について。
特に英語圏で、FPSの判定を行うゲームロジックをサーバー、それ以外をクライアントと呼ぶ。
これはTCP/IPにおけるサーバーと厳密には違う意味なので、本書ではこの意味のサーバーをホスト、
クライアントのほうをゲストと呼ぶ。

ゲームの同期に関する用語について、vol.1では独自の用語を定義していた。
まず冗長化をするかどうか。冗長化とはホストのデータのコピーをゲストでも持つかどうか。
冗長化をする場合に、非同期化をするかどうか。
冗長化とは、ゲスト側(ローカルピア)のゲーム情報をホストからの更新を待たずにsimして変えてしまうことをいう。
LANをぷちっと切断してもゲームが動いてたら冗長化・非同期化されている。
冗長化されていないものをブラウザ式と呼んでいた。
非同期化するには冗長化が必要なので、

1. 冗長かつ非同期
2. 冗長かつ同期
3. ブラウザ式

の3種類に分類している。そのうえで、「冗長かつ非同期」の場合に、
どのようにゲームプレイ体験の整合性や品質を高めていくかについて、
ゲームの内容に応じて工夫をすることについて説明していた。

英語圏でのほかの用語については、以下のような意味で使われている。

- lockstep : ゲームプレイ空間を冗長に持ち、クライアントとサーバーが足並みを揃えて(lock-step)同期をする。
- client-side : 冗長かつ非同期。　ローカルピアでの変更をサーバでチェックすることなく採用するため、クライアントで脱同期する。
- client-side, server-authoritative : 冗長かつ非同期だが、サーバから送信された結果で強制的に同期する。一時的に脱同期するが、最終的に同期。
- GGPO(rollbackつき予測入力) : 相手側の入力を予測して入力する。予測が外れた場合は、全員の入力と予測が一致する時刻まで巻き戻す。 client-side, server-authoritative の一種だが、ゲームプレイ空間の全体を自動的に補完して、個別に同期コードを書く手間を減らすことができる(場合がある)。


1,2,3の同期方式の適用範囲については注意が必要。
同期方式は、ゲーム全体について適用されるわけではなく、ゲーム内容のそれぞれについて
別々に適用できることに注意が必要である。
たとえば、マインクラフトのようなゲームの場合で、自分が操作するプレイヤーキャラクターの動きは1の「冗長かつ非同期」を採用するが、
敵キャラクターや地形の変更についてはLockstep(冗長かつ完全同期)を採用するといった何らかの併用が行われる。
したがって、あるゲームの同期方式について議論するときの細かさは、「このゲームは冗長かつ非同期」ではなく、
「このゲームの自キャラ操作はclient-sideだが、地形はlockstepである」といったような細かさでの議論が必要。

また、冗長性についても非同期性と同様に、ゲームプレイ空間の全体を完全に冗長化して共有している場合や、
キャラクターの近傍だけ共有しているが描画用の情報(ジオメトリ)だけ共有して衝突判定用データなどの論理データや
物理シミュレーションの内部データなどを共有していない場合など、さまざまな場合がありえることに注意が必要。

現在ではゲームの全体でひとつの同期方式で統一するのではなく、
ゲームの内容の各要素について、異なる同期方式を組み合わせることが普通になっていると言える。
したがって、ゲームの同期方式は、完全に同期するがネットワーク遅延の影響が直接レスポンスに反映されるlockstepから、
全く同期しないことによってネットワーク遅延の影響がレスポンスに反映されないようにするclient-sideまで、
濃淡(グラデーション)をもった概念であるということができる。


本書での呼び方は、英語圏の用語をそのまま用いれば

1. 冗長かつ非同期
- client-side : 最終的な結果がローカルピア独自になる
- client-side, host-authoritative　: 一時的にローカルピアが脱同期するが、最終的にサーバと同期される。予測入力せず、ゲームプレイ空間全体のロールバックを行わない
- GGPO : クclient-side, host-authoritative の一種だが、特殊な条件で汎用化したもの。
2. 冗長かつ同期
- lockstep : クライアントとサーバーが完全に常に同期。ただしネットワーク遅延が発生
3. ブラウザ式


混乱を避けるためにさらに説明を加える。

各ピアが脱同期している状態が完全に存在しないのは、 lockstepだけである。

client-sideでは、最終的な結果がピアごとに異なっているので、最終的にも同期しない、といえる。

client-side, server-authoritative では、一時的に脱同期しているが、最終的にサーバから最終状態を受信して同期しているので、
最終的には同期している。短く言うと「一時的に脱同期、最終的には同期」である。

GGPO-likeも、一時的に脱同期し、ロールバックをすることで同期状態に戻すことを繰り返すため、一時的に脱同期、最終的には同期、といえる。
ただし、同期を実現する方法が、ゲームの内容ごとに個別に実装するのではなく、全体でひとつのロジックを使って統一的に扱うのが異なる。




## 各方式のもうちょっと詳しい説明


A, B　2人のプレイヤーがリモートでプレイしている場合。
同期の方法(併用が可能)は、以下のように整理できる。


- lockstep: ロールバックなし、予測入力なし : 同期型またはブラウザ型
  - Aがmaster, Bがviewer. viewer側のプレイヤーは入力をAに送信し、Aでゲームを進行し、Bに結果を送る。
  - 入力してから反映までにかかる時間が1RTT(Round Trip Time).
  - ゲームロジックは決定論的でなくてもよい
  - 操作結果が無かったことになることはない
  - ゲームロジックをB側に置かなくてもよい(チート対策が可能)
    
- GGPO: ロールバックあり、予測入力あり : 非同期型、補正あり
  - A,Bで独立にゲームを進行し互いに送り合う。
  - 不一致の時はゲーム状態の履歴をさかのぼって調べ、一致するまでロールバックする。
  - ゲームロジックは決定論的でなければならない
  - ゲームプレイ空間全体のシリアライズが毎フレーム可能でなければならない
  - 1フレームで何ステップもゲーム状態を再計算できる仕組みになっている必要がある
  - アナログ入力は細かく振動して厳密な状態予測がむずかしいので難しい
  - 入力してから反映までにかかる時間が多くの場合0RTT
  - 入力が重なったときは操作結果が無かったことになる(一瞬戻される)
  - ネットワーク遅延が20〜50ms以下ぐらいであればほぼ気にならない
  - 予測入力ができれば少しましにできる
  - 人数が増えると急激に破綻が増える

- guest-side+host-authoritative : ホストでの結果を常に上書き : 非同期型、補正あり
  - すべての操作をホストで直列化し、全てのゲストでそれを最終的な結果として受け入れる
  - 不一致が起きた時は常にホストの状態で上書きしてゲストに通知するか、条件やイベントの種類をみて上書きする・しないを決める。ダメージ受けた判定はホスト、回復はゲストとか。host-authoritativeはゼロか1かではなく、補正の度合いを段階的に高めていくことができる。漸進的な開発に適している。
  - ゲームロジックは決定論的でなくてよい
  - 入力してから反映までにかかる時間が多くの場合0RTT
  - 入力が重なったときは操作結果が無かったことになる(一瞬戻される)
  - 上書きするサイドの決め方次第では完全に公平なゲーム結果にならない(タイマンするゲームに不向き)  
  
- guest-side : 非同期型、補正なし
  - A,Bで独立にゲームを進行し互いに送り合う
  - 不一致を検出すること自体をしない。
  - プログラムが簡単(あたりまえ)
  - 観戦モードのようにプレイしないクライアントなどに向いてる。
  - lockstepに一部guest-sideを併用したりもできる。
  - ゲームが破綻してもOKとする
  - 多少破綻しても大丈夫なゲームむけ
  - 最初だけ同期してもよい
  - 遅い同期: 30秒に1回とかWebAPIを用いて最新状態をとってくるだけ(ポケモンGOやIngressのような)とか。雑な同期


# 選択基準

GGPOは、ゲームロジックが決定論的であること、完全なシリアライズが可能であること、
デジタル入力であること、1フレームに何フレーム分もの高速なシミュレーションが必要、
という厳しい条件が課される。　そのため、ゲーム状態が非常に小さい対戦格闘ゲームや、
レトロゲームのエミュレーションなどでしか使えない。
対戦格闘ゲームでは必ずGGPOが必要とはいえない。
GGPOは、すでに完成してるゲームにネットワークを追加するとか、エミュレータ用のレトロゲームなどでは有効だが、
GGPOは例えばキャラや技、状況によって微調整したりが難しいので、
ゼロから作るゲームの場合は、guest-side+host-authoritative のほうが適している可能性がある。


GGPOではない場合はまず、ゲーム状態の規模が、完全な冗長化が可能な規模なら、
guest-sideで足りるか考え、不足ならhost-authoritativeに段階的に進めていく。
完全な冗長化が不可能なほど規模が大きいなら、lockstepかブラウザ型を考え、
プレイヤーキャラのジャンプについてだけguest-sideを追加し、プレイヤーの体験を少しづつ改善していくという手順が使える。
これも漸進的な開発が可能な方法である。

MMORPGのようにゲーム内容のリバースエンジニアリングを厳密に防ぎたい場合、
ゲームロジックをリモート側に置きたくないので、ブラウザ型を選択する。

クラウドゲーミングの場合、1:1や1:Nの場合は上記のことを一切考える必要がない。
N:Nの場合は、上記と同じように考える。


