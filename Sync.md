# 同期の方法を整理

オンラインゲームにおける同期まわりの用語定義と、同期方法の整理。

ゲームの状態の全体を「ゲームプレイ空間」と呼ぶ。
プレイヤーが、リモートプレイヤーとおなじゲームプレイ空間に
自分も参加してると感じるなら、それを「同期の感覚」と呼ぶ。

ゲームのシミュレーションなどの処理をしてゲームプレイ空間を変更するのを、
ゲームを進めると言う。
ゲームを進めるためのコードをゲームロジックと呼ぶ。
ゲームロジックはプレイヤーの入力を受け取ってゲームを進め、結果を画面に描画する。

## ゲームの同期における用語
まずサーバとクライアントという用語について。
特に英語圏で、FPSの判定を行うゲームロジックをサーバー、それ以外をクライアントと呼ぶ。
これはTCP/IPにおけるサーバーと厳密には違う意味なので、本書ではこの意味のサーバーをホスト、
クライアントのほうをゲストと呼ぶ。

ゲームの同期に関する用語について、vol.1では独自の用語を定義していた。
まず冗長化をするかどうか。冗長化とはホストのデータのコピーをゲストでも持つかどうか。
冗長化をする場合に、非同期化をするかどうか。
冗長化とは、ゲスト側(ローカルピア)のゲーム情報をホストからの更新を待たずにsimして変えてしまうことをいう。
LANをぷちっと切断してもゲームが動いてたら冗長化・非同期化されている。
冗長化されていないものをブラウザ式と呼んでいた。
非同期化するには冗長化が必要なので、
1. 冗長かつ非同期
2. 冗長だが同期
3. ブラウザ式

の3種類に分類している。そのうえで、「冗長かつ非同期」の場合に、
どのようにゲームプレイ体験の整合性や品質を高めていくかについて、
ゲームの内容に応じて工夫をすることについて説明していた。

英語圏でのほかの用語については、以下のように対応する。

- lockstep : 基本的には2(冗長で同期)を意味する。　ただし、ユーザからみてブラウザ式と区別ができないので、1と分離してないことがある。
- client-side : 1の素朴な実装を意味する。
- client-side, server-authoritative : 1で、ローカルピアでの変更をサーバーにも送ってチェックし、
サーバが認めた結果で上書きをするもの。
- GGPO(rollbackつき予測入力) : ゲームロジックが特殊な条件を満たすときに1をすこしましにすることができる。

本書での呼び方は、英語圏の用語について server, clientをhost, guestにおきかえて、

- lockstep
- guest-side
- guest-side+host-authoritative
- GGPO

という分け方にするのが良い・・かも(現状案)


## 


A, B　2人のプレイヤーがリモートでプレイしている場合。
同期の方法(併用が可能)は、以下のように整理できる。


- lockstep: ロールバックなし、予測入力なし : 同期型またはブラウザ型
  - Aがmaster, Bがviewer. viewer側のプレイヤーは入力をAに送信し、Aでゲームを進行し、Bに結果を送る。
  - 入力してから反映までにかかる時間が1RTT(Round Trip Time).
  - ゲームロジックは決定論的でなくてもよい
  - 操作結果が無かったことになることはない
  - ゲームロジックをB側に置かなくてもよい(チート対策が可能)
    
- GGPO: ロールバックあり、予測入力あり : 非同期型、補正あり
  - A,Bで独立にゲームを進行し互いに送り合う。
  - 不一致の時はゲーム状態の履歴をさかのぼって調べ、一致するまでロールバックする。
  - ゲームロジックは決定論的でなければならない
  - ゲームプレイ空間全体のシリアライズが毎フレーム可能でなければならない
  - 1フレームで何ステップもゲーム状態を再計算できる仕組みになっている必要がある
  - アナログ入力は細かく振動して厳密な状態予測がむずかしいので難しい
  - 入力してから反映までにかかる時間が多くの場合0RTT
  - 入力が重なったときは操作結果が無かったことになる(一瞬戻される)
  - ネットワーク遅延が20〜50ms以下ぐらいであればほぼ気にならない
  - 予測入力ができれば少しましにできる
  - 人数が増えると急激に破綻が増える

- guest-side+host-authoritative : ホストでの結果を常に上書き : 非同期型、補正あり
  - すべての操作をホストで直列化し、全てのゲストでそれを最終的な結果として受け入れる
  - 不一致が起きた時は常にホストの状態で上書きしてゲストに通知するか、条件やイベントの種類をみて上書きする・しないを決める。ダメージ受けた判定はホスト、回復はゲストとか。host-authoritativeはゼロか1かではなく、補正の度合いを段階的に高めていくことができる。漸進的な開発に適している。
  - ゲームロジックは決定論的でなくてよい
  - 入力してから反映までにかかる時間が多くの場合0RTT
  - 入力が重なったときは操作結果が無かったことになる(一瞬戻される)
  - 上書きするサイドの決め方次第では完全に公平なゲーム結果にならない(タイマンするゲームに不向き)  
  
- guest-side : 非同期型、補正なし
  - A,Bで独立にゲームを進行し互いに送り合う
  - 不一致を検出すること自体をしない。
  - プログラムが簡単(あたりまえ)
  - 観戦モードのようにプレイしないクライアントなどに向いてる。
  - lockstepに一部guest-sideを併用したりもできる。
  - ゲームが破綻してもOKとする
  - 多少破綻しても大丈夫なゲームむけ
  - 最初だけ同期してもよい
  - 遅い同期: 30秒に1回とかWebAPIを用いて最新状態をとってくるだけ(ポケモンGOやIngressのような)とか。雑な同期


# 選択基準

GGPOは、ゲームロジックが決定論的であること、完全なシリアライズが可能であること、
デジタル入力であること、1フレームに何フレーム分もの高速なシミュレーションが必要、
という厳しい条件が課される。　そのため、ゲーム状態が非常に小さい対戦格闘ゲームや、
レトロゲームのエミュレーションなどでしか使えない。
対戦格闘ゲームでは必ずGGPOが必要とはいえない。
GGPOは、すでに完成してるゲームにネットワークを追加するとか、エミュレータ用のレトロゲームなどでは有効だが、
GGPOは例えばキャラや技、状況によって微調整したりが難しいので、
ゼロから作るゲームの場合は、guest-side+host-authoritative のほうが適している可能性がある。


GGPOではない場合はまず、ゲーム状態の規模が、完全な冗長化が可能な規模なら、
guest-sideで足りるか考え、不足ならhost-authoritativeに段階的に進めていく。
完全な冗長化が不可能なほど規模が大きいなら、lockstepかブラウザ型を考え、
プレイヤーキャラのジャンプについてだけguest-sideを追加し、プレイヤーの体験を少しづつ改善していくという手順が使える。
これも漸進的な開発が可能な方法である。

MMORPGのようにゲーム内容のリバースエンジニアリングを厳密に防ぎたい場合、
ゲームロジックをリモート側に置きたくないので、ブラウザ型を選択する。

クラウドゲーミングの場合、1:1や1:Nの場合は上記のことを一切考える必要がない。
N:Nの場合は、上記と同じように考える。


